
Основные команды Bash
Перемещение по файловой системе и работа с ней.
1. cd
  cd </path/to/directory>
Сокращенное change directory. Позволяет перемещаться по файловой системе.

Путь может быть как абсолютным (начмнаться с /), так и относительным (подразумевается расположение пути относительно текущего).

Рис. 1

cd без параметров перемещает в домашнюю директорию пользователя.
cd - перемещает по прошлому пути.
. (точка) текущая директория
.. (две точки) родительская директория
~ (тильда) домашняя директория пользователя
2. pwd
  pwd
Cокращение от print work directory. Выводит текущий абсолютный путь.

Рис. 2

3. ls
  ls </path/to/directory>
Сокращение от list. Отбражает все файлы и директории в директории </path/to/directory>.

Рис. 3

ls без параметров отображает все файлы и директории по текущему пути
ls -a отображает скрытые файлы и папки
ls -l отображает расширенную информацию о файлах и папках
4. cat
  cat <file_name>
Отображает содержимое файла file_name.

Рис. 4

5. less
  less <file_name>
Отображает содержимое файла file_name, выводит только содержимое помещающееся в окно терминала. Навигация по файлу возможна клавишами-стрелками, кнопка "q" закрывает просмотр.

Рис. 5

Рис. 5-5

6. file
  file <file_name>
Выводит на экран тип файла. Настоящий тип, а не указанный в расширении.

Рис. 6

7. cp
  cp <file1> <file2>
Сокращение от copy. Копирует файл file1 по пути file2.

8. mv
  mv file1 file2
Сокращение от move.

Перемещает файл file1 по пути file2.

9. rm
  rm <file1>
Сокращение от remove.

Удаляет файл file1.

rm -r удаляет директорию
10. mkdir
  mkdir <directory>
Сокращение от make directory.

Создает директории с именем directory.

11. locate
  locate <file>
Возвращает все пути с вхождениями file в них.

12. man
  man <cmd>
Отображает справку по команде cmd.

13. echo
  echo <string>
Выводит заданную строку string на экран.

14. strings
  strings <file1>
Выводит все строки с печатными символами из файла file1 на экран.

Перенаправление вывода
Bash позволяет перенаправлять стандартный вывод в файлы с помощью оператора >. Если файл не существовал, он будет создан, иначе он будет перезаписан.

$ echo hello! > 1.txt
$ ls
1.txt
$ cat 1.txt
hello!
Если требуется дописать строку в файл используется оператор >>.

Конвейер
Если нужно перенаправить вывод одной команды на вход другой используется оператор |.

  $ locate bin | less
Поиск по содержимому файлов
  $ grep [opts] "pattern" file
  $ cat file | grep [opts] "pattern"
-v - вывести строки, где не всречается образец
-i - игнорировать регистр символов
-n - печатать номера строк
-a - искать по бинарным файлам
-E - расширенные регулярные выражения
-o - вывести только совпадающую с образцом часть строки

Регулярные выражения
  $ egrep [opts] "pattern" file
  $ cat file | egrep [opts] "pattern"
^ "^license" - начало строки
$ "license$" - конец строки
[abc] "[0-9]" - любой символ из перечисленных
[^abc] "[^ ]1" - любой кроме перечисленных
[ab]{8} "w{3}" - повторяется несколько раз
(abc) "(license)" - группа символов
. "Li.en.e" - любой символ
* "\([a-z ]*\" - повторить ноль или больше раз
+ "\(a.+\)" - повторить один или больше раз
? "(copy)?right" - повторить ноль или один раз

Обработка текста
Вывести символы со 2 по 5 каждой строки

  $ cat file | cut -c 2-5
Отсортировать строки по алфавиту

  $ cat file | sort
Удалить одинаковые строки, идущие подряд

  $ cat file | uniq
Вывести уникальные строки

  $ cat file | sort | uniq
  $ cat file | awk 'program'
'{print $0}' - вывести каждую строку '{print $1}' - вывести первое слово каждой строки '{print "1: " $1 ", 2: " $2}' - вывести для каждой строки 1:<слово 1>, 2:<слово 2>






-----------------------------------------------------------------------------
------------------------------------------------------------------------------




Bash

Отличия в синтаксисе
Подавляющее большинство важных скриптов командного процессора Bourne могут выполняться без изменения в bash, за исключением тех, которые ссылаются на специальные переменные Bourne или используют встроенные команды Bourne. Синтаксис команд Bash включает идеи, заимствованные у Korn shell (ksh) и C shell (csh), такие как редактирование командной строки, история команд, стек каталогов, переменные $RANDOM и $PPID, синтаксис замены команды $(…). Когда Bash используется как интерактивный командный процессор, он поддерживает автозавершение имён программ, файлов, переменных и т. п. с помощью клавиши Tab ↹.

Внутренние команды
Интерпретатор bash имеет множество встроенных команд, часть из которых имеют аналогичные исполняемые файлы в операционной системе. Однако следует обратить внимание, что чаще всего для встроенных команд отсутствуют man-страницы, а при попытке просмотра справки по встроенной команде на самом деле будет выдаваться справка по исполняемому файлу. Исполняемый файл и встроенная команда могут отличаться параметрами. Информация по встроенным командам расписана в справочной странице bash:

man bash

Ввод-вывод
echo	выводит выражение или содержимое переменной (stdout), но имеет ограничения в использовании[3]
printf	команда форматированного вывода, расширенный вариант команды echo
read	«читает» значение переменной со стандартного ввода (stdin), в интерактивном режиме это клавиатура
Файловая система
cd	изменяет текущий каталог
pwd	выводит название текущего рабочего каталога (от англ. print working directory)
pushd	изменяет текущий каталог с возможностью возврата в обратном порядке
popd	возвращает текущий каталог после pushd
dirs	выводит или очищает содержимое стека каталогов, сохранённых через pushd
Действия над переменными
let	производит арифметические операции над переменными
eval	транслирует список аргументов из списка в команды
set	изменяет значения внутренних переменных скрипта
unset	удаляет переменную
export	экспортирует переменную, делая её доступной дочерним процессам
declare, typeset	задают и/или накладывают ограничения на переменные
getopts	используется для разбора аргументов, передаваемых скрипту из командной строки
Управление сценарием
source, . (точка)	запуск указанного сценария
exit	безусловное завершение работы сценария
exec	заменяет текущий процесс новым, запускаемым командой exec
shopt	позволяет изменять ключи (опции) оболочки на лету
Команды
true	возвращает код завершения ноль (успешное завершение)
false	возвращает код завершения, который свидетельствует о неудаче
type prog	выводит полный путь к prog
hash prog	запоминает путь к prog
help COMMAND	выводит краткую справку по использованию внутренней команды COMMAND
Управление запущенными в командной оболочке задачами
jobs	показывает список запущенных в командной оболочке задач, либо информацию о конкретной задаче по её номеру
fg	переключает поток ввода на текущую задачу (или на определённую задачу, если указан её номер) и продолжает её исполнение
bg	продолжает исполнение текущей приостановленной задачи (или определённых задач, если указаны их номера) в фоновом режиме
wait	ожидает завершения указанных задач
Скрипты
В простейшем случае, скрипт — простой список команд, записанный в файл. Командный процессор должен знать, что он должен этот файл обработать, а не просто прочесть его содержимое. Для этого служит специальная конструкция, называемая shebang: #!. Символ # задаёт комментарий, но в данном случае shebang означает, что после этого спецсимвола находится путь к интерпретатору для исполнения сценария.

Синтаксис
Синтаксис команд bash — это расширенный синтаксис команд Bourne shell. Окончательная спецификация синтаксиса команд bash есть в Bash Reference Manual, распространяемом проектом GNU.[4]

«Hello world»
#!/usr/bin/env bash
echo 'Hello World!'
Этот скрипт содержит только две строки. Первая строка сообщает системе о том, какая программа используется для запуска файла. Вторая строка — это единственное действие, которое выполняется этим скриптом, он собственно печатает «Hello world!» в терминале.

Запуск скрипта
Для того, чтобы скрипт стал исполняемым, могут быть использованы следующие команды:

chmod +rx scriptname # выдача прав на чтение/исполнение любому пользователю
chmod u+rx scriptname # выдача прав на чтение/исполнение только "владельцу" скрипта
Из соображений безопасности путь к текущему каталогу . не включён в переменную окружения $PATH. Поэтому для запуска скрипта необходимо явно указывать путь к текущему каталогу, в котором находится скрипт:

./scriptname
Кроме того, передать такой файл на исполнение интерпретатору Bash можно и явно, используя команду bash:

bash scriptname
В этом случае не требуется ни установка прав доступа, ни использование последовательности #! в коде.

Перенаправление ввода-вывода
См. также: Стандартные потоки
В bash есть встроенные файловые дескрипторы: 0 (stdin), 1 (stdout), 2 (stderr).

stdin — стандартный ввод — то, что набирает пользователь в консоли;
stdout — стандартный вывод программы;
stderr — стандартный вывод ошибок.
Для операций с этими и пользовательскими дескрипторами существуют специальные символы: > (перенаправление вывода), < (перенаправление ввода). Символы &, - могут предварять номер дескриптора; например, 2>&1 — перенаправление дескриптора 2 (stderr) в дескриптор 1 (stdout).

0<filename или <filename	Перенаправление ввода из файла filename
1>filename или >filename	Перенаправление вывода в файл «filename». Если отключена опция noclobber, то файл перезаписывается поступающими данными
1>|filename или >|filename	Перенаправление вывода в файл «filename», файл перезаписывается поступающими данными
1>>filename или >>filename	Перенаправление вывода в файл «filename», данные добавляются в конец файла. При отсутствии файла он создаётся
2>filename	Перенаправление стандартного вывода ошибок в файл «filename»
2>>filename	Перенаправление стандартного вывода ошибок в файл «filename», данные добавляются в конец файла. При отсутствии файла он создаётся
&>filename	Перенаправление вывода и ошибок в файл «filename»
2>&1	Перенаправление вывода ошибок на стандартный вывод
Bash имеет индивидуальный синтаксис перенаправления, который не поддерживается в Bourne shell. Пример одновременного перенаправления стандартного вывода и стандартных ошибок:

command &> file
Это проще набрать, чем эквивалентную команду в синтаксисе Bourne shell

command > file 2>&1
Перенаправление «из кода скрипта»
Поддерживается heredoc-синтаксис:

С интерпретацией переменных и конструкций языка внутри блока:
$a='многострочный'
command <<MYDOC123
$a
текст
$(<$HOME/my_file.txt)
MYDOC123
Без интерпретации переменных:
command <<'PERLCODE'
my $first='Hello';
my $second='world';
say join(', ',$first,$second),'!';
PERLCODE
С удалением начальных отступов (поддерживаются только отступы табуляцией):
command <<-'TABSTRIP'
    for ((i=0; i<10; i++))
    do
        echo "$i"
    done
TABSTRIP
Начиная с версии 2.05b, bash может перенаправлять стандартный ввод из строки, используя следующий синтаксис «here strings»:

command <<< "string to be read as standard input"
Если строка содержит пробелы, её следует заключить в кавычки или апострофы, либо экранировать пробелы обратной косой чертой.

Будьте внимательны: вводимая с использованием here strings строка содержит неявную последовательность завершения строки: либо 1 дополнительный байт line feed, либо 2 дополнительных байта: carriage return и line feed.

cat -<<<'123' | wc -c
# Результат: 4
cat <(echo -n '123') | wc -c
# Результат: 3
wc -c <<<'123'
# Результат: 4
echo -n 123 | wc -c
# Результат: 3
Начиная с версии 4.1[5] стало возможным указывать в одной строке терминирующую последовательность символов и, сразу за ней, — скобку. Это может быть полезно для присвоения переменной содержимого here-doc:

var=$( cat -<<'TERMSEQ'
Февраль. Достать чернил и плакать!
Писать о феврале навзрыд,
Пока грохочущая слякоть
Весною чёрною горит.
TERMSEQ)
При этом BASH будет сгенерировано предупреждающее сообщение.

Перенаправление для процесса в целом
Пример (перенаправление стандартного вывода в файл, запись данных, закрытие файла, сброс stdout):

# make Filedescriptor(FD) 6 a copy of stdout (FD 1)
exec 6>&1
# open file "test.data" for writing
exec 1>test.data
# produce some content
echo "data:data:data"
# close file "test.data"
exec 1>&-
# make stdout a copy of FD 6 (reset stdout)
exec 1>&6
# close FD6
exec 6>&-
Открытие и закрытие файлов:

# open file test.data for reading
exec 6<test.data
# read until end of file
while read -u 6 dta
do
  echo "$dta" 
done
# close file test.data
exec 6<&-
Подстановка вывода команд
Захват вывода внешних команд:

# выполнить 'date' и поместить результат в VAR
VAR="$(date)"
echo "$VAR" #выведет дату на момент вызова предыдущей строки
При этом не поддерживаются строки с нуль-символом, заключительные переводы строк пропадают, в отличие от каналов и прочего файлового ввода-вывода.

Условный оператор
#!/usr/bin/env bash
T1='foo'
T2='bar'
if [[ $T1 == "$T2" ]] 
then
  echo 'условие выполняется'
else
  echo 'условие не выполняется'
fi
Обратите внимание, что кавычки вокруг левой части необязательны.[6]

Циклы
#!/usr/bin/env bash
for i in "Номер "{1..10}
do
  echo "$i"
done
#!/usr/bin/env bash
COUNTER=0
while [[ $COUNTER -lt 10 ]] 
do
  echo The counter is $COUNTER
  let COUNTER=COUNTER+1
done
#!/usr/bin/env bash
i=0
until [[$i -eq 10]] 
do
  echo "$i"
  i=$(($i+1))
done
#!/usr/bin/env bash
# внутри двойных круглых скобок переменные можно писать в Си-стиле (без $ и разделяя пробелом операторы и операнды)
for (( i = 0; i < 10; i++ ))
do
	echo -n "$i; "
done
Массивы
В bash реализованы только одномерные массивы. Индексами могут быть как целочисленные значения («обычный» массив), так и строки (ассоциативный массив, или «хеш»).

Несмотря на унификацию синтаксиса для работы с обычными и ассоциативными массивами, первые не являются разновидностью вторых ни с точки зрения конечного пользователя, ни с точки зрения внутренней логики самого интерпретатора.

Как естественное следствие поддержки «ассоциативных» ключей, в bash существует крайне ограниченная возможность эмуляции многомерных массивов.

Общие операции
Получить строку, состоящую из всех[7] элементов массива, разделённых пробелом.

values="${arr[@]}"
Получить строку со всеми[7] индексами или ключами массива, независимо от того, численные они или текстовые:

keys="${!arr[@]}"
Осуществить массовую замену первого вхождения подстроки «MAY» на «MARCH» во всех[7] элементах массива и вернуть строку, составленную из результирующих элементов массива, разделённых пробелом:

values="${arr[@]/MAY/MARCH}"
То же самое, но в каждом[7] элементе массива будут заменены все вхождения подстроки «MAY»:

values="${arr[@]//MAY/MARCH}"
До сих пор не все заявленные в документации возможности правильно работают для массивов. Например:

[ -v 'имя_массива' ]
неправильно срабатывает для пустого массива.[8]

Операции с индексированными массивами
Bash имеет поддержку одномерных массивов. Инициализировать элементы массива можно в виде: my_array[xx]. Также можно явно объявить массив в сценарии, с помощью директивы declare:

declare -a my_array
Обращаться к отдельным элементам массива можно с помощью фигурных скобок: "${my_array[xx]}".

Инициализировать индексированный массив можно двумя способами:

1)

Array=(element1 element2 element3)
2)

temp_array[0]=element1
temp_array[5]=element
temp_array[9]=elementN
Добавление элементов в конец индексированного массива:

declare -a arrAnimals
arrAnimals=(dog elephant horse cow fox koala turtle)
# Выводим содержимое массива:
echo "${arrAnimals[@]}"
# В конец массива arrAnimals добавляем новый элемент: "pig"
arrAnimals+=(pig)
# И снова показываем содержимое массива:
echo "${arrAnimals[@]}"
Получить первый элемент массива:

echo "${arrAnimals[0]}"
Как индексированные, так и ассоциативные массивы поддерживают так называемые «срезы»:

# Ещё один способ получить первый элемент массива
echo "${arrAnimals[@]:0:1}"

# Вывести 3 элемента массива, начиная со 2-го:
echo "${arrAnimals[@]:2:3}"
Примечание: в случае с ассоциативными массивами порядок следования значений в общем случае будет случайным (определяется используемой хеш-функцией), поэтому операция среза на ассоциативном массиве хотя и допустима, но имеет крайне ограниченную область практического применения.

В массивах с числовыми индексами допустима «обратная» («негативная») адресация, позволяющая получить доступ к элементам, начиная с конца массива:

# Значение последнего элемента массива
echo "${arrAnimals[-1]}"
# Значение предпоследнего элемента массива
echo "${arrAnimals[-2]}"
# ... и т.д.
С помощью встроенной команды mapfile (синоним: readarray) можно отображать содержимое текстового файла в индексированный массив:

declare -a fileWithLogins
mapfile fileWithLogins </etc/passwd
for ((i=0; i<${#fileWithLogins[@]}; i++))
do
	echo "Line #$i: ${fileWithLogins[$i]}"
done
Операции с ассоциативными массивами
Начиная с версии 4.0 в bash появилась поддержка ассоциативных массивов (так называемых hash-массивов).

Для объявления ассоциативных массивов используется ключ -A встроенной команды declare:

declare -A hshArray
Как и в случае с индексированными массивами, для заполнения ассоциативных массивов могут использоваться два различных синтаксиса:

1)

TheCapitalOf[Georgia]='Tbilisi'
TheCapitalOf[Australia]='Canberra'
TheCapitalOf[Pakistan]='Islamabad'
2)

TheCapitalOf=([Georgia]='Tbilisi' [Australia]='Canberra' [Pakistan]='Islamabad')
С помощью ассоциативных массивов можно имитировать поддержку многомерных массивов:

declare -A a # объявляет ассоциативный массив 'a'
i=1; j=2 # инициализация нескольких индексов
a[$i,$j]=5 # присвоение значения "5" в ячейку "$i,$j" (т.е. "1,2")
echo ${a[$i,$j]} # вывод хранимых значений из "$i,$j"
К сожалению, в текущих версиях bash скопировать содержимое одного ассоциативного массива в другой простым присваиванием невозможно. Данную проблему можно только обойти, для чего существуют два принципиально разных подхода:

1) Эмулировать объявление второго хеша «с нуля» путём копирования объявления первого хеша:

declare -A hsh1
hsh1=(...)

source <(declare -p hsh1 | sed 's/^declare -A hsh1/declare -A hsh2/')
2) Перебрать все[7] элементы хеша-источника и скопировать их в целевой хеш:

declare -A hsh1 hsh2
hsh1=(...)

for k in "${!hsh1[@]}"
do
	hsh2["$k"]="${hsh1["$k"]}"
done
Безопасная работа с массивами
Массивы являются удобным способом передачи динамически генерированных аргументов в функции или команды. При этом каждый элемент массива представляет собой отдельный аргумент.

args=( -l -a / )
ls "${args[@]}" # ls -l -a /
ls ${args[@]} # ls -l -a /
ls ${args[*]} # ls -l -a /
Однако при подобном использовании массивов следует быть осторожным ввиду особенностей раскрытия массивов при использовании в качестве индексов специальных символов @ и *.

Если массив заключён в кавычки и раскрывается с помощью индекса @, то образуется строка из слов, где каждое слово — отдельный элемент массива. Однако если не заключить раскрытие массива в двойные кавычки, то может получиться совсем другой результат: пробелы, входящие в состав элементов массива, становятся разделителями слов.

args=( -l -a '/home/user/Рабочий стол' )
ls "${args[@]}" # просмотр содержимого каталога '/home/user/Рабочий стол'
ls ${args[@]} # ошибка: каталогов '/home/user/Рабочий' и './стол' не существует
Массив с индексом *, заключённый в двойные кавычки, раскрывается в одну строку, соединяя все элементы массива через разделители, хранимые в переменной IFS. Если не указать двойные кавычки, то массив раскрывается аналогично раскрытию при использовании индекса @.

args=( '' usr local bin )
IFS='/' ls "${args[*]}" # просмотр содержимого каталога '/usr/local/bin'
IFS='/' ls ${args[*]} # поочерёдный просмотр содержимого каталогов '.', './usr', './local' и './bin'
При создании массива из содержимого текстовой переменной необходимо учитывать возможное наличие пробелов в тексте. Например, в качестве одного из способов создания массива из строки с перечислением можно рассматривать замену символа-разделителя на пробел. Однако наличие пробелов в разделяемых элементах приведёт к дроблению самих элементов на части.

array=( ${text//,/} ) # неправильно: текст в переменной 'text' мог содержать пробельные символы

IFS=',' array=( $text ) # правильно: раздельтельным символом является запятая.
IFS=',' read -r -a array <<< "$text" # правильно (альтернативный вариант с перенаправлением содержимого переменной 'text' в команду 'read')
К ошибкам может привести создание массива из текста, полученного в качестве вывода команд или из файла, т. к. не только переводы строк, но также и пробелы с символами табуляции по умолчанию будут считаться разделителями[9].

array=( "$(ls)" ) # неправильно: пробелы в названии файлов могут разбить имя файла на два элемента массива

IFS=$'\n' array=( "$(ls)" ) # правильно: разделителем будет только перевод строк
mapfile -t array < <(ls) # правильно: альтернативный вариант через встроенную команду mapfile
Конвейер
Конвейер передаёт вывод предыдущей команды на ввод следующей или на вход командного интерпретатора. Метод часто используется для связывания последовательности команд в единую цепочку. Конвейер обозначается символом |.

Пример (grep работает как фильтр для стандартного вывода):

cat filename | grep pattern
Логические операции
Логическое ИЛИ обозначается как ||. В операциях проверки условий оператор || возвращает 0 (success), если один из операндов имеет значение true (ИСТИНА).

Логическое И обозначается как &&. В операциях проверки условий оператор && возвращает 0 (success) тогда и только тогда, когда оба операнда имеют значение true (ИСТИНА).

Примечание: Возможная путаница в понимании возникает из-за того, что команда true (и успешное завершение любой команды) завершается с кодом возврата 0, success (false, наоборот, не 0), в то время как логическое значение true/false — отлично от нуля/равно нулю.

Примеры:

if false; then echo "successfully"; else echo "unsuccessfully"; fi
unsuccessfully
let "a=(( 1 && 0 && 123))"; echo $?; echo $a
1 # Код завершения команды
0 # Значение переменной "a", результат логической операции
if (( 1 && 0 && 123)); then echo "true"; else echo "false"; fi
false
let "a=(( 1 && 123 && -345 ))"; echo $?; echo $a
0 # Код завершения команды
1 # Значение переменной "a", результат логической операции
if (( 1 && 123 & -345 )); then echo "true"; else echo "false"; fi
true
false && echo "Успешное завершение" || echo "Неуспешное завершение"
Неуспешное завершение
Целочисленная математика
Bash может выполнять целочисленные вычисления внутри процесса, используя команду ((…)) и синтаксис переменной $((…))[10], как показано ниже:

VAR=55 # Устанавливаем переменную VAR, равной 55
((VAR = VAR + 1)) # Добавляем единицу к переменной VAR. Обратите внимание на отсутствие знака '$' 
((VAR+=1)) # Сокращённая форма записи инкремента
((++VAR)) # Другой способ увеличения VAR на единицу. Выполняет префиксный инкремент
((VAR++)) # Другой способ увеличения VAR на единицу. Выполняет постфиксный инкремент
echo $((VAR * 22)) # Умножаем VAR на 22 и передаем результат команде
echo $[VAR * 22] # Устаревший способ сделать то же
((VAR<<3)) # Побитовый сдвиг влево (то же, что VAR*8)
((VAR>>3)) # Побитовый сдвиг вправо (то же, что VAR/8)
Команда ((…)) также может использоваться в условных утверждениях, так как её исходный параметр — это 0 или 1, которые могут интерпретироваться как true или false:

if ((VAR == Y * 3 + X * 2))
then
  echo Yes 
fi
((Z > 23)) && echo Yes
Команда ((…)) поддерживает следующие операторы ставнения: == != > < >= <=.

Bash не поддерживает вычисления внутри процесса с числами с плавающей точкой. Только командные процессоры Unix Korn shell (версия 1993 года) и zsh (начиная с версии 4.0) поддерживают эту возможность.

Список математических операций: +, -, *, /, ** (возведение в степень), % (деление по модулю, остаток от деления), let — позволяет использовать сокращения арифметических команд (сокращая количество используемых переменных; например: a += b эквивалентно a = a + b и т. п.).

Переменные и аргументы
Аргументы:

$$	pid текущего shell (самого процесса-сценария)
$!	pid последнего процесса в фоновом режиме
$?	код возврата последнего процесса (функции или скрипта)
$x	где x — номер параметра, переданного скрипту ($1, $2 и т. д., $0 — последний запущенный скрипт)
$#	количество аргументов командной строки
$*	все[7] аргументы в виде одной строки (слова)
$@	то же самое, что и $*, но при этом каждый[7] параметр представлен как отдельная строка (слово)
$-	список флагов, переданных сценарию
$_	содержит последний аргумент предыдущей команды
Встроенные переменные:

$BASH	путь к исполняемому файлу bash
$BASH_VERSINFO[n]	массив, состоящий из 6 элементов, содержащий информацию о версии bash
$BASH_VERSION	версия Bash, установленного в системе
$DIRSTACK	содержимое вершины стека каталогов
$EDITOR	заданный по умолчанию редактор
$EUID	«эффективный» идентификационный номер пользователя (Effective User ID)
$FUNCNAME	имя текущей функции
$GLOBIGNORE	перечень шаблонных символов, которые будут проигнорированы при выполнении подстановки имён файлов (globbing)
$GROUPS	группы, к которым принадлежит текущий пользователь
$HOME	домашний каталог пользователя
$HOSTNAME	сетевое имя хоста
$HOSTTYPE	тип машины (идентифицирует аппаратную архитектуру)
$IFS	разделитель полей во вводимой строке
$LC_COLLATE	задаёт порядок сортировки символов, в операциях подстановки имён файлов и в поиске по шаблону
$LC_CTYPE	определяет кодировку символов
$LINENO	Номер строки исполняемого сценария
$MACHTYPE	аппаратная архитектура
$OLDPWD	прежний рабочий каталог
$OSTYPE	тип операционной системы
$PATH	путь поиска (включает в себя каталоги /usr/bin/, /usr/X11R6/bin/, /usr/local/bin и т. д.)
$PIPESTATUS	Код возврата канала (конвейера)
$PPID	PID (идентификатор) родительского процесса
$PS1	приглашение командной строки
$PS2	вторичное приглашение командной строки, выводится тогда, когда от пользователя ожидается дополнительный ввод. Обычно отображается как «>»
$PS3	третичное приглашение, выводится, когда пользователь должен сделать выбор в операторе select
$PS4	приглашение четвёртого уровня, выводится (в изменённом виде) в начале каждой строки отладочного вывода тогда, когда сценарий вызывается с ключом -x. Обычно отображается как «+», «++» и т. д.
$PWD	рабочий (текущий) каталог
$REPLY	переменная по умолчанию, куда записывается ввод пользователя, выполненный с помощью команды read
$SECONDS	время работы сценария (в секундах)
$SHELLOPTS	список допустимых опций интерпретатора (доступна только для чтения)
$SHLVL	уровень вложенности shell
Регулярные выражения внутри процесса
Bash 3.0 поддерживает встроенные регулярные выражения с синтаксисом, подобным синтаксису Perl:

[[string =~ regex]]
Синтаксис регулярных выражений задокументирован на страницах документации man 7 regex. Статус выхода устанавливается в 0, если регулярное выражение совпало со строкой, и 1, если нет. Значение подвыражения, заключённого в скобки, можно получить[7] через переменную ${BASH_REMATCH[@]}, например:

REGEXP='foo(bar)bl(.*)'
if [["abcfoobarbletch" =~ $REGEXP]] 
then
  echo "Регулярное выражение совпало со строкой!" 
  echo "$BASH_REMATCH"      # выводит: foobarbletch 
  echo "${BASH_REMATCH[1]}" # выводит: bar 
  echo "${BASH_REMATCH[2]}" # выводит: etch 
fi
Встроенные регулярные выражения обычно работают быстрее, чем выполнение внешней команды grep, потому что соответствующее регулярное выражение выполняется в рамках процесса bash. Если регулярное выражение или строка содержат пробелы или метасимволы (такие как * или ?), их следует взять в кавычки. Рекомендуется использовать переменную для хранения регулярного выражения, как в вышеприведённом примере, для избежания проблем с экранированием специальных символов. Можно использовать вывод bash с опцией -x для проверки, как именно bash воспринимает ваше регулярное выражение.

Расширение скобок
Возможность расширения скобок заимствована у csh. Она позволяет произвольной строке быть сформированной с использованием похожей техники, как это делается с названиями файлов. Однако в bash сгенерированные строки не обязаны быть именами файлов. Результат каждого расширения строки не сортируется, сохраняется порядок слева направо:

# Это особенность присущая bash
echo a{p,c,d,b}e # ape ace ade abe
Не следует использовать эту особенность, если скрипт планируется портировать, потому что в традиционных скриптах расширение строки не будет действовать:

# Традиционная оболочка не даёт тот же результат
echo a{p,c,d,b}e # a{p,c,d,b}e
Когда используется расширение скобок в сочетании с символами подстановки, скобки раскрываются первыми, а затем результат обрабатывается в обычном режиме. Таким образом, список JPEG- и PNG-изображений в текущем каталоге может быть получен так:

ls *.{jpg,jpeg,png} # скобки раскрываются до *.jpg *.jpeg *.png, после чего выполняется поиск по маскам
Горячие клавиши
Tab ↹: Автодополнение строки за курсором.
Ctrl+! Ctrl+!: Повторить последнюю команду.
Ctrl+a: Перемещает курсор в начало строки (эквивалентно клавише Home).
Ctrl+b: Перемещает курсор на один символ назад (эквивалентно клавише ←).
Ctrl+r: Поиск по набранным ранее командам.
Ctrl+c: Посылает сигнал SIGINT текущему заданию, который обычно (но не всегда) прекращает и закрывает его.
Ctrl+d: Посылает маркер EOF, который (если не отключено опцией и текущая строка не содержит текста) закрывает текущую оболочку (эквивалентно команде exit), при вводе в исполняющуюся программу завершает ввод, если в строке нет текста, иначе завершает строку без символа завершения строки.
Ctrl+d: Удаляет текущий символ (только если есть текст на текущей строке) (эквивалентно клавише Delete).
Ctrl+e: Перемещает курсор в конец строки (эквивалентно клавише End).
Ctrl+f: Перемещает курсор на один символ вперёд (эквивалентно клавише →).
Ctrl+h: Удаляет предыдущий символ (то же самое, что и клавиша ← Backspace).
Ctrl+i: Эквивалентно клавише Tab ↹.
Ctrl+j: Эквивалентно клавише ↵ Enter.
Ctrl+k: Очищает содержимое строки после курсора и копирует это в буфер обмена экземпляра bash (kill ring).
Ctrl+l: Очищает содержимое экрана (эквивалентно команде clear).
Ctrl+m: Эквивалентно клавише ↵ Enter.
Ctrl+n: (следующее) перелистывает к следующей команде (эквивалентно клавише ↓).
Ctrl+o: Выполняет найденную команду в истории, и выбирает следующую строку относительно текущей строки в истории для того, чтобы отредактировать.
Ctrl+p: (предыдущее) перелистывает к предшествующей команде (эквивалентно клавише ↑).
Ctrl+q: Возобновить вывод процесса.
Ctrl+s: Приостановить вывод процесса (stop).
Ctrl+t: Обмен местами соседних символов.
Ctrl+u: Очищает содержание строки до курсора и копирует его в буфер обмена экземпляра bash (kill ring).
Ctrl+w: Убирает слово до курсора и копирует его в буфер обмена экземпляра bash (kill ring).
Ctrl+y: добавляет содержимое буфера обмена экземпляра bash от позиции курсора.
Ctrl+z: Посылает сигнал SIGTSTP текущему заданию, который приостанавливает его выполнение, и возобновляет приём команд. Для возобновления его выполнения в фоновом режиме можно ввести команду bg. Для того, чтобы вернуть его из фонового режима или приостановки, можно выполнить fg.
Ctrl+/: Прервать текущий процесс с дампом памяти (core dump), послав ему сигнал.
Ctrl+_ (Ctrl+⇧ Shift+-): Откат редактирования.
Alt+>: переход к последней команде в истории.
Alt+b: (назад) перемещает курсор назад на одно слово (эквивалентно клавише Ctrl+←).
Alt+d: Сокращает слово после курсора.
Alt+f: (вперёд) перемещает курсор вперёд на одно слово (эквивалентно клавише Ctrl+→).
Alt+t: Меняет два слова перед курсором местами.
Alt+.: Добавляет последний аргумент предыдущей команды.
Alt+c: Заменить букву под курсором на заглавную.
Alt+l: Заменить букву под курсором на строчную.
Ctrl+x Ctrl+x: Переносит курсор к началу строки от текущей позиции, и обратно.
Ctrl+x Ctrl+e: Редактирует текущую строку в программе $EDITOR, или vi, если не предопределено.
Ctrl+x Ctrl+v: Вывод на экран информации о версии текущего экземпляра bash.
Стартовые скрипты
Bash при запуске вызывает команды из множества различных скриптов.

Когда bash вызывается как интерактивная оболочка входа в систему, первым делом он читает и вызывает команды из файла /etc/profile, если этот файл существует. После чтения этого файла он смотрит следующие файлы в следующем порядке: ~/.bash_profile, ~/.bash_login и ~/.profile, читает и вызывает команды из первого, который существует и доступен для чтения. При выходе bash читает и выполняет команды из файла ~/.bash_logout.

Когда запускается интерактивная оболочка, но не для входа в систему, bash читает и исполняет команды из файлов /etc/bash.bashrc и ~/.bashrc, если они существуют. Это может быть отменено опцией -norc. Опция -rcfile file заставит bash использовать команды из файла file вместо /etc/bash.bashrc и ~/.bashrc.

Переносимость
Первой строкой скрипта должна быть запись #!/bin/bash, если известен абсолютный путь к исполняемому файлу, либо #!/usr/bin/env bash для автоматического определения пути к исполняемому файлу через команду env с помощью переменной окружения PATH[11].

Скрипты оболочек, написанные со специфическими для bash особенностями, не будут работать на системах, где используется Bourne shell (sh) или один из его аналогов, если bash не был установлен в качестве дополнительной оболочки. Эта проблема стала особенно важной, когда Ubuntu начал с октября 2006 года поставлять Debian Almquist shell (dash) как скриптовую оболочку по умолчанию, что привело к неработоспособности многочисленных скриптов.

Графический интерфейс к скриптам
Существует множество программ, позволяющих создавать графический интерфейс к bash-скриптам.

dialog — утилита, позволяющая создавать диалоговые окна в консоли, использует библиотеки curses и ncurses.
whiptail — аналог утилиты dialog, использует библиотеку newt.
zenity — наиболее популярное приложение для создания графического интерфейса к скриптам.
kdialog — аналог zenity в среде KDE.
yad — форк zenity, с большими возможностями.
xdialog — замена dialog, предназначенная для придания запускаемым из терминала программам интерфейса X Window System.
gtkdialog — наиболее функциональная утилита для создания графических приложений на bash-скриптах.





--------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------




Командная​ ​строка​ ​Ubuntu:​ ​основные​ ​команды​ ​bash
17.06.2016 11:07 #Linux/Ubuntu
Введение
Для работы в Ubuntu пользователь может выбрать один из двух возможных вариантов интерфейса: графический либо интерфейс командной строки. Графический интерфейс (GUI - Graphical user interface) знаком большинству пользователей, в нем для выполнения действий нужно использовать различные элементы рабочего стола. Он имеет свои преимущества, которые выражаются главным образом в удобном и привычном формате подачи информации, а также в отсутствии необходимости знать какие-либо команды.

Однако многие пользователи Linux предпочитают работать в командной строке (CLI, Command Line Interface). Как правило, эти пользователи так или иначе связаны с программированием или системным администрированием, тем не менее знание основ bash будет полезно всем пользователям. Командная строка позволяет выполнять команды значительно быстрее, чем при использовании GUI, при этом экономит ресурсы. Более того, зачастую команды не имеют своих аналогов в графическом интерфейсе и, благодаря этому, дают значительную свободу пользователям в своих действиях. При этом интерфейс командной строки встроен в ядро операционной системы, а значит, он доступен даже тогда, когда вы не можете воспользоваться графической оболочкой. Сами же команды одинаковы для всех операционных систем на базе Linux, будь то Ubuntu, CentOs, Fedora или какая-либо другая.

Что такое bash
Bash расшифровывается как Bourne again shell (что можно перевести как «Еще одна оболочка Борна»), название частично заимствованно от более ранней версии командной оболочки UNIX, которая называлась просто Bourne shell («Оболочка Борна» – по фамилии разработчика Стивена Борна).

Bash позволяет интерактивно взаимодействовать с компьютером, вводя определенные команды и получая на них соответствующий отклик. Также этот командный процессор позволяет выполнять скрипты (команды из файла), может производить автодополнение названий файлов и директорий, допускает использование переменных, операторов ветвления и цикла.
Далее в статье будут приведены самые простые и необходимые для работы в bash команды, которые помогут вам сориентироваться и начать самостоятельно использовать командную строку для своих задач, но сначала необходимо перейти к интерфейсу командной строки.

Вход в командную строку
Используя Ubuntu в качестве операционной системы, вы можете перейти к командной строке двумя путями, а именно через консоль или через терминал.
Если вы хотите зайти в командную строку через терминал, то для этого необходимо нажать Ctrl+Alt+F(1-6) – в зависимости от выбранного номера (F1, F2…) вы попадаете в первую, вторую или другую по счету виртуальную консоль (они независимы и запускаются во время загрузки Ubuntu), каждая из которых имеет интерфейс командной строки. Если вы нажмете Ctrl+Alt+F7, то перейдете в седьмую виртуальную консоль, которая имеет графический интерфейс.

Что касается терминала, то это графическая программа, которая эмулирует консоль. Вы можете найти ее в меню, выбрав «Приложения», затем «Стандартные», а затем «Терминал», либо нажав сочетание клавиш Ctrl+Alt+T. Вы сможете выполнять команды, продолжая находиться в графическом интерфейсе.
Также возможен вариант, когда вам необходимо подключиться к серверу, на котором установлена Ubuntu. В этом случае вам нужно воспользоваться специальной программой (например, puTTy): наберите нужный ip-адрес, а затем введите имя пользователя и пароль.

Примечание.
При вводе пароля в командную строку он не высвечивается – вам нужно просто набрать пароль и нажать Enter. Если пароль введен правильно, вы сможете продолжить работу в командной строке.

Пользователь и система
Используя bash, вы можете легко получить любую необходимую вам техническую информацию о пользователях и системе.
Если вы хотите идентифицировать, под каким пользователем авторизованы в данный момент, вам нужно ввести в командную строку следующую команду:

whoami
Если вам нужно узнать не только о вашем, но и о других пользователях, находящихся в данный момент в этой операционной системе, используйте команды:

who
или

w
В отличие от whoami, эти команды показывает более подробную информацию: кроме имени пользователя вы также узнаете о том, какая используется терминальная линия, время начала сеанса, IP-адрес и некоторые другие данные.

Что касается данных о системе, то с ними можно ознакомиться, используя команду uname. Сама по себе эта команда даст вам не так много информации – только название системы. Однако если вы будете использовать ключи, то сможете узнать гораздо больше.

Ключи – это специальные аргументы, которые пишутся через пробел после команды и начинаются с одного или двух дефисов. Они определяют параметры, которые будут применены к команде. Как правило, узнать о доступных ключах вы можете, написав команду и --help (либо -help): к примеру,

uname --help
У команды uname вы можете задать ключ -a (или --all), и тогда на экран будет выведена вся информация об операционной системе:

uname -a
Если вас интересуют конкретно данные о ядре, то наберите следующую команду:

uname -rv
В этом случае вы узнаете о релизе и версии ядра операционной системы.
Получить информацию обо всех процессах можно при помощи этой команды:

ps -a
А команда pstree выведет информацию в виде дерева процессов.

Узнать сетевое имя машины вы можете с помощью команды hostname.

Переход по директориям
В этом разделе вы познакомитесь с основными командами bash, которые позволят вам выполнять самые простые действия в командной строке.
Команда cd позволяет переходить из одной директории в другую. При этом если вы используете команду без ключей, то попадете в домашнюю директорию; для того, чтобы перейти в какую-либо конкретную директорию, необходимо просто прописать ее путь, к примеру:

cd /home/users/dir1
Вы также можете указывать команду cd с определенными ключами:

cd ../.. - переход на две директории выше;

cd -     - переход в предыдущую директорию (в которой вы были до перемещения в нынешнюю).

Команда pwd укажет путь той директории, в которой вы в данный момент находитесь.

Создание, перемещение и удаление
Используйте команду mkdir для создания директории. Не забудьте указать имя:

mkdir dir1
Новая директория будет создана в той директории, где вы находитесь в данный момент, но вы также можете прописать какой-то другой путь для создания новой директории:

mkdir /home/users/dir1
Для создания файла вам нужно ввести команду touch и название будущего файла:

touch file1
В этом случае прописать путь, где нужно создать файл, тоже возможно:

touch /home/users/dir1/file1
Для перемещения директорий и файлов используется команда mv, после которой вы пишете название директории или файла, который хотите переместить, а затем место, куда хотите переместить:

mv file2 /home/users/dir2

mv dir1 /home/users/dir3
Обратите внимание, что команда mv также используется для переименования, поэтому если при отсутствии директории dir2 вы напишете такую команду:

mv dir1 dir2
то директория dir1 будет переименована в директорию dir2. Этот пример справедлив и для файлов, которым вы можете давать другие названия при помощи команды mv.

Для удаления файлов следует использовать команду rm, а для удаления директорий rmdir. Если вы хотите удалить каталог, используйте команду rm с ключами -rf:

rm -rf /home/users/
Еще одно действие, которое вы можете использовать, - это копирование при помощи команды cp. Синтаксис у этой команды такой же, как и у предыдущих, - вы просто пишете, что и куда хотите скопировать. Для копирования директории обязательно нужно использовать ключ -r, при этом если конечная директория (dir2) не существует, то она будет создана при копировании:

cp -r dir1 dir2
Информация о файлах, каталогах и процессах
Для вывода информации о содержании каталога используется команда ls. Если использовать ее без ключей, то она просто выведет информацию об имеющихся в данной (или указанной) директории файлах и директориях. Основные ключи, которые часто используются с этой командой:

-a - вам будут показаны все файлы директории, в том числе те, которые начинаются с . (точки);

-s - запрос информации о размерах файлов (или директорий);

-l - данные о файлах, в частности имя пользователя, который их создал, права доступа и время создания;

-h - перевод размера файлов в удобном для восприятия формат (Кбайт, Мбайт и т.д.).

Также ключи можно комбинировать, поэтому обычно для вывода размера содержимого используется команда:

ls -sh
Другой командой, которая поможет вам получить необходимую информацию, является команда du. К примеру, введя эту команду:

du -sk *
вы получите информацию о размерах и именах файлов.

Информацию о работающих процессах вы можете получить при помощи команды df. Лучше всего использовать ее сразу с ключом -h, чтобы данные были показаны в более удобном для чтения формате:

df -h
Поиск и использование регулярных выражений
Для поиска файлов в bash используется команда find. Ее синтаксис следующий: find + нужная директория (путь) + ключ (или несколько) + критерии ключа + (опционально) последующее действие над найденными файлами.

Со множеством ключей этой команды, которые значительно облегчают и сужают поиск, вы можете ознакомиться, введя в командную строку:

find --h
К примеру, следующая команда позволит вам найти все файлы, которые находятся в директории dir1, и имеют название file:

find /home/users/dir1 -name ‘file*’
Для поиска наиболее удобно пользоваться некоторыми регулярными выражениями, а именно:

* - обозначает любое количество символов, включая их отсутствие (например, по запросу file* будут найдены все файлы: file, file1, file829, fileabc и т.д.);

? - обозначает один символ (по запросу file? будут найдены файлы с одним символом после слова file: file1, file9, filea и т.д.; по запросу file?? будут найдены файлы с двумя символами: file12, file34, file92 и т.д.);

[] - обозначает подмножество значений, которые может принимать один символ (по запросу file[1-9] будут найдены файлы: file1, file2, file3 и так далее до file9; по запросу file[a-d] файлы filea, fileb, filec и filed).

Перенаправление и конвейер
Перенаправление вывода какой-либо команды задается символом > либо >>. Различие в том, что при использовании > вывод команды будет записан поверх содержимого файла, а при использовании >> вывод дописывается в конец файла.

Этим очень удобно пользоваться для логирования, если вы хотите записать какие-либо данные в файл. К примеру, эта команда запишет все найденные согласно указанными параметрам файлы в файл log (он автоматически появится в той директории, в которой вы работаете):

find /home/users -name ‘file*’ >> log
Что касается конвейера, то этот инструмент позволяет использовать вывод одной команды в качестве ввода другой команды. Для этого необходимо использовать символ |:

find /home/users -name ‘file*’ | sort -r
Если вы введете данную строку, то сначала будут найдены все файлы, которые соответствуют условию, а затем командой sort они будут отсортированы в обратном порядке (из-за использования ключа -r).

Содержимое файлов
Если вы хотите посмотреть содержимое файла, то можете обратиться к команде cat - в ответ на команду вы увидите все, что содержится в файле. Если данных слишком много, используйте конвейер и команду more - она позволит просматривать содержимое постранично:

cat file1 | more
Если вам нужно не только посмотреть содержимое файла, но и отредактировать его, тогда нужно использовать одну из утилит: nano либо vim. Это текстовые редакторы, при помощи которых вы можете открыть файл, изменить и сохранить его. Несмотря на кажущееся сходство, эти утилиты имеют ряд отличий; большинство пользователей сходится во мнении, что nano представляет собой более простой редактор, в то время как vim обладает большими возможностями.

С русскоязычной документацией nano вы можете ознакомиться по этой ссылке: http://help.ubuntu.ru/wiki/nano

А документация vim доступна в этом разделе: http://help.ubuntu.ru/wiki/vim

Заключение
Существует множество различных команд и ключей, которые можно использовать в bash. В данной статье мы остановились лишь на самых основных, базовых командах, при помощи которых вы сможете выполнять операции и получать необходимую информацию.

Полную русскоязычную документацию вы можете найти по этому адресу: http://help.ubuntu.ru/wiki/



-----------------------------------------------------------------
-------------------------------------------------------------------


Основы линукс: Введение в bash

 
О чем статья
Прочитав эту статью, вы узнаете что такое bash (стандартный командный интерпретатор линукс), научитесь обращаться со стандартными командами: ls, cp, mv… поймете назначение инодов, жестких и символических ссылок и многое другое.

Это пособие предназначено для новичков в линукс и для тех, кто хочет повторить или усовершенствовать понимание основных принципов линукс, таких как копирование и перемещение файлов, создание ссылок, использование стандартных команд линукс наряду с перенаправлениями и пайпами. В этой статье вы найдете множество примеров, поясняющих изложенный материал. Для начинающих большинство информации окажется новой, а для более продвинутых пользователей этот материал может стать прекрасным пособием для обобщения имеющихся знаний и навыков.

Введение в bash
Shell
Если вы используете линукс, то знаете что после логина вас приветствует приглашение командного интерпретатора. Например такое:

\$ 
Если после логина загружается графическая оболочка, то чтобы добраться до командного интерпретатора нужно запустить эмулятор терминала (gnome-terminal, xfce4-terminal, konsole, xterm, rxvt…) или переключиться на один из виртуальных терминалов нажав Ctrl–Alt–F1 или Ctrl–Alt–F2 и т.д.

Приглашение командного интерпретатора на вашем компьютере может отличаться от того что показано в примере. Оно может содержать имя пользователя, имя компьютера и название текущей рабочей директории. Но несмотря на все эти различия, программа которая печатает это приглашение называется «shell» (оболочка), и скорее всего в роли вашей командной оболочки выступает программа которая называется bash.

У вас запущен bash?
Проверить запущен ли bash можно следующей командой:

\$ echo \$SHELL
/bin/bash
Если в результате выполнения этой команды вы получили ошибку или её вывод отличается от того что в примере, то возможно в вашей системе в качестве командной оболочки используется не bash. Несмотря на это, большая часть материала будет актуальна, но все же рекомендуем вам переключиться на bash. Сделать это можно (если bash установлен в системе) командой:

\$ bash
Что такое bash
Bash (акроним от «Bourne-again SHell») это стандартный интерпретатор команд на большинстве линукс систем. В его обязанности входит обработка и исполнение команд с помощью которых пользователь управляет компьютером. После того как вы завершили работу, можно завершить процесс командного интерпретатора. После нажатия клавиш Ctrl–D, команд exit или logout процесс командного интерпретатора будет завершен и на экране снова появится приглашение ввести имя пользователя и пароль.

Использование «cd»
Давайте начнем использовать bash для навигации по файловой системе. Для начала напечатайте следующую команду:

$ cd /
Этой командой мы указали bash-у что хотим переместиться в корневую директорию — /. Все директории в системе организованы в древовидную структуру и / это её начало (или корень). Команда cd служит для изменения текущей рабочей директории.

Пути
Чтобы узнать в каком месте файловой системы в данный момент вы находитесь (текущую рабочую директорию) наберите:

\$ pwd
/
В приведенном выше примере / — аргумент команды cd — называется путь. Это место файловой системы, куда мы хотим переместиться. В данном случае / — абсолютный путь, это значит что путь указан относительно корневой директории.

Абсолютные пути
Вот несколько примеров абсолютных путей

/dev
/usr
/usr/bin
/usr/local/bin
Как вы уже могли заметить, все эти пути объединяет то, что они начинаются с /. Указывая путь /usr/local/bin в качестве аргумента команде cd мы говорим ей перейти в корневую директорию /, затем в директорию usr, потом в local и bin. Абсолютные пути всегда начинаются с /

Относительные пути
Второй вид путей называется относительными. Bash, команда cd и другие команды отсчитывают эти пути относительно текущей директории. Относительные пути никогда не начинаются с /. Например, если мы находимся в /usr

\$ cd /usr
Затем мы можем перейти в /usr/local/bin используя относительный путь

\$ cd local/bin
\$ pwd
/usr/local/bin
Использование «..»
Относительные пути могут содержать одну или несколько директорий «..». «..» указывает на родительскую директорию по отношению к нашей рабочей директории. Пример:

\$ pwd
/usr/local/bin
\$ cd ..
\$ pwd
/usr/local
Как вы видите, команда cd .. ‘поднимает нас на уровень выше’.

Можно добавить .. к относительному пути. Это позволит переместиться в директорию, которая находится на одном уровне с той в которой мы находимся. Пример:

\$ pwd
/usr/local
\$ cd ../share
\$ pwd
/usr/share
Примеры с использованием относительных путей
Относительные пути могут быть довольно сложными. Вот несколько примеров. Результат выполнения команд не показан, попробуйте определить в какой директории вы окажетесь используя bash.

\$ cd /bin
\$ cd ../usr/share/zoneinfo

\$ cd /usr/X11R6/bin
\$ cd ../lib/X11

\$ cd /usr/bin
\$ cd ../bin/../bin
Рабочая директория «.»
Перед тем как закончить разговор о команде cd, следует упомянуть еще несколько вещей. Во-первых, существует ещё одна специальная директория «.», которая указывает на текущую директорию. Эта директория используется для запуска исполняемых файлов, находящихся в текущей директории.

\$ ./myprog
В последнем примере myprog это исполняемый файл находящийся в текущей директории, который будет запущен на исполнение.

cd и домашняя директория пользователя
Для того чтобы перейти в домашнюю директорию, нужно набрать

\$ cd
Без аргумента cd переместит вас в домашнюю директорию. Для суперпользователя домашней обычно является директория /root, а для обычных пользователей — /home/username/. Но что если мы хотим указать конкретный файл, находящийся в домашней директории. Например, как аргумент к программе ‘myprog’? Можно написать:

\$ ./myprog /home/user/myfile.txt
Однако, использовать абсолютные пути к файлам не всегда удобно. Эту же операцию можно сделать при помощи ~–тильды:

\$ ./myprog ~/myfile.txt
~ — специальное имя, указывающее в bash на домашнюю директорию пользователя.

Домашние директории других пользователей
Но что если нам нужно указать файл в домашней директории другого пользователя? Для этого после тильды нужно указать имя этого пользователя. Например, чтобы указать на файл fredsfile.txt находящийся в домашней директории пользователя fred:

\$ ./myprog ~fred/fredsfile.txt
Команды линукс
Введение в ls
Вероятно вы уже знакомы с командой ls, которая, вызванная без аргументов, выводит на экран список файлов хранящихся в рабочей директории:

\$ cd /usr
\$ ls
X11R6      doc         i686-pc-linux-gnu  lib      man          sbin   ssl
bin        gentoo-x86  include            libexec  portage      share  tmp
distfiles  i686-linux  info               local    portage.old  src
Если указать опцию -a, можно будет увидеть все файлы, включая скрытые (имена которых начинаются с точки).

\$ ls -a
.      bin        gentoo-x86         include  libexec  portage      share  tmp
..     distfiles  i686-linux         info     local    portage.old  src
X11R6  doc        i686-pc-linux-gnu  lib      man      sbin         ssl
Подробный список директорий
После самой команды ls в качестве ее аргумента можно указать один или более файлов или директорий. Если указать имя файла, то команда ls выведет информацию только об этом файле. А если указать название директории, ls покажет все ее содержимое. Опция ‘-l’ команды ls бывает очень полезной если вы хотите кроме имен файлов узнать более подробную информацию о них (права на файл, имя владельца, время последнего изменения файла и его размер).

В следующем примере показано применение опции ‘-l’ для вывода информации о файлах хранящихся в директории /usr


 
\$ ls -l /usr
drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -> share/doc
drwxr-xr-x   62 root     root         1856 Dec 27 15:54 gentoo-x86
drwxr-xr-x    4 root     root          152 Dec 12 23:10 i686-linux
drwxr-xr-x    4 root     root           96 Nov 24 13:17 i686-pc-linux-gnu
drwxr-xr-x   54 root     root         5992 Dec 24 22:30 include
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 info -> share/info
drwxr-xr-x   28 root     root        13552 Dec 26 00:31 lib
drwxr-xr-x    3 root     root           72 Nov 25 00:34 libexec
drwxr-xr-x    8 root     root          240 Dec 22 20:57 local
lrwxrwxrwx    1 root     root            9 Dec 22 20:57 man -> share/man
lrwxrwxrwx    1 root     root           11 Dec  8 07:59 portage -> gentoo-x86/
drwxr-xr-x   60 root     root         1864 Dec  8 07:55 portage.old
drwxr-xr-x    3 root     root         3096 Dec 22 20:57 sbin
drwxr-xr-x   46 root     root         1144 Dec 24 15:32 share
drwxr-xr-x    8 root     root          328 Dec 26 00:07 src
drwxr-xr-x    6 root     root          176 Nov 24 14:25 ssl
lrwxrwxrwx    1 root     root           10 Dec 22 20:57 tmp -> ../var/tmp
В первой колонке показана информация о правах доступа к каждому файлу в списке. (Немного позже я объясню какая буква что обозначает) Следующая колонка показывает количество ссылок на каждый элемент списка. Третья и четвертая колонки — владелец и группа файла соответственно. Пятая колонка — размер. Шестая — время последнего изменения файла (‘last modified time’ или mtime). Последняя колонка — имя файла или директории (Если это ссылка, то после знака ‘–>‘ стоит имя объекта на который она ссылается).

Как посмотреть только директории
Иногда возникает потребность посмотреть информацию только о директориях, а не о всем их содержимом. С этой задачей поможет справиться опция ‘-d’, которая указывает команде выводить информацию только о директориях. Пример:

\$ ls -dl /usr /usr/bin /usr/X11R6/bin ../share
drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
drwxr-xr-x    2 root     root         3192 Dec 26 12:52 /usr/X11R6/bin
drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin
Рекурсивный список и информация о инодах
Действие опции ‘-R’ противоположно действию ‘-d’. Она позволяет выводить информацию о файлах находящихся в директории рекурсивно. Сначала показывается содержимое директории верхнего уровня, потом по очереди содержимое всех поддиректорий и так далее. Вывод этой команды может быть достаточно объемным, поэтому мы не приводим ее пример, но вы можете попробовать сделать это самостоятельно, набрав в командной строке ‘ls -R‘ или ‘ls -Rl‘.

И, наконец, опция ‘-i’ используется для вывода инодов каждого объекта файловой системы.

\$ ls -i /usr
1409 X11R6        314258 i686-linux           43090 libexec        13394 sbin
1417 bin            1513 i686-pc-linux-gnu     5120 local          13408 share
8316 distfiles      1517 include                776 man            23779 src
43 doc            1386 info                 93892 portage        36737 ssl
70744 gentoo-x86     1585 lib                   5132 portage.old      784 tmp
Что такое иноды?
Каждый объект файловой системы (файл, директория…) имеет свой уникальный номер, называемый инодом (inode number). Эта информация может показаться незначительной, но понимание функции инодов поможет вам разобраться во многих операциях над файловой системой. Например, посмотрим на «.» и «..» как на ссылки, присутствующие в каждой директории. Чтобы понять что из себя представляет директория «..», узнаем инод директории /use/local

\$ ls -id /usr/local
5120 /usr/local
Как можем видеть, инод директории /usr/local — 5120. Теперь посмотрим какой инод у директории /usr/local/bin/..:

\$ ls -id /usr/local/bin/..
5120 /usr/local/bin/..
Получается, что иноды директорий /usr/local и /usr/local/bin/.. совпадают! Это значит, что на инод 5120 ссылаются два имени: /usr/local и /usr/local/bin/.. То есть это два разных имени одной директории. Каждый инод указывает на определенное место на диске.

С каждым инодом может быть связано несколько имен объектов файловой системы. Количество ‘синонимов’ файла (объектов файловой системы, ссылающихся на один инод) показывает число во втором столбце вывода команды ‘ls -l‘.

\$ ls -dl /usr/local
drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local
На этом примере видно (второй столбец), что на директорию /usr/local ссылаются 8 разных объектов файловой системы. Вот их имена:

/usr/local
/usr/local/.
/usr/local/bin/..
/usr/local/games/..
/usr/local/lib/..
/usr/local/sbin/..
/usr/local/share/..
/usr/local/src/..
mkdir
Давайте рассмотрим команду mkdir. Она служит для создания новых директорий. В следующем примере демонстрируется создание трех новых директорий (tic, tac, toe) в директории /tmp

\$ cd /tmp
$ mkdir tic tac toe
По умолчанию команда mkdir не может создать вложенной структуры директорий. Поэтому, если вам нужно создать несколько вложенных одна в другую директорий (won/der/ful), то вам придется три раза поочередно вызывать эту команду:

\$ mkdir won/der/ful
mkdir: cannot create directory 'won/der/ful': No such file or directory
\$ mkdir won
\$ mkdir won/der
\$ mkdir won/der/ful
Упростить эту операцию можно добавив опцию ‘-p’ к команде mkdir. Эта опция позволяет создавать вложенную структуру директорий:

\$ mkdir -p easy/as/pie
Чтобы узнать о возможностях этой утилиты подробнее, прочитайте справку, которая вызывается командой man mkdir. Справки есть практически ко всем командам из этого руководства (например man ls), кроме cd, т.к. она встроена в bash (для таких команд справка вызывается так: help cd)

touch
Перейдем к изучению команд cp и mv, служащих для копирования, переименования и перемещения файлов и директорий. Но перед этим создадим пустой файл в директории /tmp при помощи команды touch:

\$ cd /tmp
\$ touch copyme
Команда touch обновляет время последнего доступа к файлу (шестая колонка вывода команды ls -l) если он уже существует или создает новый пустой файл, если его ещё нету. После этой операции у нас должен появиться пустой файл /tmp/copyme.

echo
Теперь, когда у нас есть пустой файл, запишем в него текстовую строку при помощи команды echo, которая выводит переданный ей аргумент на стандартное устройство вывода (текстовый терминал в нашем случае).

\$ echo "firstfile"
firstfile
Чтобы записать строку в наш файл, перенаправим в него вывод команды echo:

\$ echo "firstfile" > copyme
Знак > (больше) указывает командной оболочке что нужно перенаправить вывод команды стоящей слева в файл, имя которого находится справа. Если файла с таким именем не существует, он будет создан автоматически. А если такой файл уже есть, то он будет перезаписан (все его содержимое будет стерто перед записью нашей строки). Команда ‘ls -l’ покажет что размер нашего файла теперь равен 10 байтам — девять байт занимает слово ‘firstfile’ и один байт символ перевода строки.

\$ ls -l copyme
-rw-r--r--    1 root     root           10 Dec 28 14:13 copyme
cat и cp
Для вывода содержимого файла на терминал используется команда cat:

\$ cat copyme
firstfile
Теперь мы можем приступить к разбору базовой функциональности команды cp. Эта команда принимает два аргумента. Первый — имя уже существующего файла (‘copyme’), второй — название новой копии, которую мы хотим сделать (‘copiedme’).

\$ cp copyme copiedme
Можем убедиться, что новая копия файла имеет другой номер инода (это значит что мы получили действительно новый отдельный файл, а не просто ссылку на старый)

\$ ls -i copyme copiedme
648284 copiedme   650704 copyme
mv
Теперь применим команду mv чтобы переименовать файл («copiedme» –> «movedme»). Номер инода после этой операции не меняется, а изменяется только название файла.

\$ mv copiedme movedme
\$ ls -i movedme
648284 movedme
Номер инода не изменяется только при условии, что переименованный файл остается в пределах той файловой системы где находился исходный файл. Мы рассмотрим подробнее устройство файловых систем в одной из следующих частей этого пособия.

Команда mv позволяет не только переименовывать файлы, но и перемещать их. Например, чтобы переместить файл /var/tmp/myfile.txt в директорию /home/user нужно дать команду:

\$ mv /var/tmp/myfile.txt /home/user
Файл будет перемещен в домашнюю директорию пользователя user даже если она находится в другой файловой системе (в этом случае файл будет скопирован в новое место после чего оригинал будет удален). Как вы могли уже догадаться, перемещение файла в другую файловую систему приводит к изменению его инода. Это происходит потому, что каждая файловая система имеет свой отдельный набор инодов.

Нужно заметить, существует вероятность, что новый присвоенный номер инода может совпасть со старым, но она чрезвычайно мала.
Чтобы переместить одновременно несколько файлов в одну директорию нужно написать:

\$ mv /var/tmp/myfile1.txt /var/tmp/myfile2.txt /home/user
или

\$ mv -t /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
Если добавить опцию ‘-v’, на экран будет выведен отчет о проделанной операции:

\$ mv -vt /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
'/var/tmp/myfile1.txt' -> '/home/user/myfile1.txt'
'/var/tmp/myfile2.txt' -> '/home/user/myfile2.txt'

 
-----------------------------------------------------------------
---------------------------------------------------------------
 



Оболочка Bash — шпаргалка для начинающих
12 января 2017 в 18:28, Переводы
 8 минут
 51 135
Kseniya Sazonova
В данной шпаргалке затрагиваются следующие темы: введение в оболочку, навигация, основные команды, переменные окружения, коннекторы, конвейеры, перенаправление ввода/вывода, права доступа и комбинации клавиш. 

Оболочка Bash: введение
Оболочка, или шелл (shell) — это программа, в нашем случае названная «bash», что является сокращением от Bourne Again Shell. Оболочка принимает ваши команды и передаёт их операционной системе. Для взаимодействия с системой используются терминалы, такие как gnome-terminal, eterm, nxterm и т. п.

Навигация
В Linux файлы и каталоги имеют иерархическую организацию, то есть существует некий начальный каталог, называемый корневым. В нём содержатся файлы и подкаталоги, которые в свою очереди содержат файлы и свои подкаталоги.

pwd
Команда pwd, сокращение от print working directory, отображает текущее местоположение в структуре каталогов.

cd
Команда cd позволяет перейти в новый каталог.

Синтаксис	Объяснение
cd	Перемещение в домашний каталог
cd ~	Перемещение в домашний каталог
cd ..	Перемещение на один уровень выше
cd -	Перемещение в предыдущий каталог
cd Directory1	Перемещение в каталог Directory1
cd Directory1/Directory2	Перемещение в каталог Directory2 по указанному пути
mkdir
Команда mkdir создаёт новый каталог в текущем каталоге.

Основные команды
man
Команда man отображает руководства по командам. Например, следующая команда выдаст всю информацию о команде cat:

$ man cat
cat
Команда cat считывает файл, переданный как аргумент, и выводит его содержимое по стандартному каналу вывода. Передача нескольких файлов в виде аргумента приведёт к выводу конкатенированного содержимого всех файлов.

echo
Команда echo выводит свои аргументы по стандартному каналу вывода.

$ echo Hello World
  Hello World
Если вызвать echo без аргументов, будет выведена пустая строка.

head
Команда head читает первые 10 строк любого переданного текста и выводит их по стандартному каналу. Число выводимых строк можно изменить:

$ head -50 test.txt
tail
Команда tail работает аналогично команде head, но читает строки с конца:

$ tail -50 test.txt
Также можно просматривать добавляемые к файлу строки в режиме реального времени при помощи флага -f:

$ tail -f test.txt
less
Команда less позволяет перемещаться по переданному файлу или куску текста, причём в обоих направлениях.

$ less test.txt
$ ps aux | less
Подробнее о назначении символа | будет рассказано ниже в разделе команды history.

Обычные сочетания клавиш	Описание
G	Перемещает в конец файла
g	Перемещает в начало файла
:50	Перемещает на 50 строку файла
q	Выход из less
/searchterm	Поиск строки, совпадающей с ‘searchterm’, ниже текущей строки
/	Перемещает на следующий подходящий результат поиска
?searchterm	Поиск строки, совпадающей с ‘searchterm’, выше текущей строки
?	Перемещает на следующий подходящий результат поиска
up	Перемещает на одну строку выше
down	Перемещает на одну строку ниже
pageup	Перемещает на одну страницу выше
pagedown	Перемещает на одну страницу ниже
true
Команда true всегда возвращает ноль в качестве выходного статуса для индикации успеха.

false
Команда false всегда возвращает не-ноль в качестве выходного статуса для индикации неудачи.

$?
$? — это переменная, которая содержит выходной статус последней запущенной команды. Под статусом обычно понимается код возврата программы. 0 означает успешное выполнение программы, любое значение большее 0 отражает тот факт, что в процессе выполнения возникли некоторые ошибки. Кстати, именно поэтому в bash истинной (true) считается 0, а все, что не 0 — ложью (false):

$ true
$ echo $?
  0
$ false
$ echo $?
  1
grep
Команда grep занимается поиском переданной строки в указанном файле:

$ cat users.txt
  user:student password:123
  user:teacher password:321
$ grep 'student` file1.txt
  user:student password:123
grep также может принимать несколько файлов и регулярных выражений для уточнения формата текста.

Обычные флаги	Описание
-i	Отключение чувствительности к регистру
-r	Рекурсивный поиск по директориям
-w	Поиск только целых слов
-c	Вывод количества найденных элементов
-n	Вывод всей строки, содержащей запрос
-v	Вывод инвертированного совпадения
Также можно ознакомиться с руководством по regex. У нас на сайте тоже есть руководство по «регуляркам» в Python для новичков.

sed
Команда sed — это потоковый редактор, преобразующий входные текстовые данные. Обычно её используют для замены выражений так: s/regexp/replacement/g. Например, следующий код заменит все слова «Hello» на «Hi»:

$ cat test.txt
  Hello World
$ sed 's/Hello/Hi/g' test.txt
  Hi World
Также вы можете ознакомиться с руководством по sed.

history
Команда history выводит историю командной строки. Обычно её используют вместе с командой grep для поиска конкретной команды. Например, следующий код найдёт все команды, содержащие строку g++:

$ history | grep g++
  155  g++ file1.txt
  159  g++ file2.txt
Здесь также используется символ | — это так называемый конвейер (pipe). Благодаря ему можно перенаправлять вывод одной команды на вход другой — таким образом в примере выше вся история, которая в обычном режиме выводится командой history прямо в вывод терминала, будет перенаправлена в grep в качестве входных данных. Мы не увидим вывода команды history, но увидим вывод команды grep.

Это может быть довольно сложно для понимания без практики, поэтому поэкспериментируйте самостоятельно, например с командами ls, history, ps (описана ниже), перенаправляя их вывод в grep, sed или less, например.

export
Команда export устанавливает переменные окружения для передачи дочерним процессам. Например, так можно передать переменную name со значением student:

$ export name=student
ps
Команда ps выводит информацию о запущенных процессах.

$ ps
  PID TTY          TIME CMD
  35346 pts/2    00:00:00 bash
Выводится четыре элемента:

ID процесса (PID),
тип терминала (TTY),
время работы процесса (TIME),
имя команды, запустившей процесс (CMD).
awk
Команда awk находит и заменяет текст в файлах по заданному шаблону: awk 'pattern {action}' test.txt

wget
Команда wget скачивает файлы из Сети и помещает их в текущий каталог.

$ wget https://github.com/mikeizbicki/ucr-cs100
nc
Команда nc — это утилита для отладки сети. Также можно ознакомиться с руководством по nc.

ping
Команда ping тестирует сетевое подключение.

$ ping google.com
  PING google.com (74.125.224.34) 56(84) bytes of data.
  64 bytes from lax17s01-in-f2.1e100.net (74.125.224.34): icmp_req=1 ttl=57 time=7.82 ms
  --- google.com ping statistics ---
  1 packets transmitted, 1 received, 0% packet loss, time 8ms
  rtt min/avg/max/mdev = 7.794/8.422/10.792/0.699 ms
Статистика в конце показывает количество подключений, совершённых до завершения команды, и время их выполнения.

git
Git — это популярная система контроля версий. Также можно ознакомиться с руководством по git и нашими материалами.

Переменные окружения
Переменные окружения — это именованные переменные, содержащие значения, используемые одним или несколькими приложениями.

Переменная PATH содержит список каталогов, в которых система ищет исполняемые файлы.


 
Переменная HOME содержит путь к домашнему каталогу текущего пользователя.

Коннекторы
Коннекторы позволяют запускать несколько команд одновременно.

Коннектор	Описание
&&	Первая команда исполняется всегда, вторая — только в случае успешного завершения первой
||	Первая команда исполняется всегда, вторая — только в случае неудачного завершения первой
;	Команды исполняются всегда
$ true && echo Hello
  Hello
$ false || echo Hello
  Hello
$ echo Hello ; ls
  Hello
  test.txt file1.txt file2.txt
Конвейеры
Конвейеры, или пайпы, позволяют соединять входные и выходные каналы различных команд. В следующем примере вывод команды ls будет передан в head , и в результате будет напечатано лишь 10 первых элементов.

$ ls -l | head
Перенаправление ввода/вывода
Перенаправление вывода
Для стандартного перенаправления вывода используются символы > и >>.

Например, этот код передаст вывод ls в файл, а не на экран:

$ ls > files.txt
$ cat files.txt
  file1.cpp sample.txt
Если файл не существует, он создаётся, а если существует, то перезаписывается. Во избежание перезаписи стоит использовать команду >> — она дописывает данные в конец файла.

Перенаправление ввода
Для стандартного перенаправления вывода используется символ <. В следующем примере sort берет входные данные из файла, а не с клавиатуры:

$ cat files.txt
  c
  b
$ sort < files.txt
  b
  c
Команда sort выводит содержимое файла на экран, поскольку мы не перенаправили выход. Это можно сделать так:

$ sort < files.txt > files_sorted.txt
Продвинутое перенаправление
Добавление & к > приводит к перенаправлению как стандартного потока выхода, так и потока ошибок. Например, файл test.cpp выведет строку stdout в cout и строку stderr в cerr.

$ g++ test.cpp
$ ./a.out >& test.txt
$ cat test.txt
  stdout
  stderr
Если вы хотите вывести конкретный файловый дескриптор, вы можете приписать его номер к >.

Имя	Дескриптор	Описание
stdin	0	Стандартный поток ввода
stdout	1	Стандартный поток вывода
stderr	2	Стандартный поток вывода ошибок
Например, для перенаправления stderr в test.txt нужно сделать следующее:

$ g++ test.cpp
$ ./a.out 2> test.txt
  stdout
$ cat test.txt
  stderr
Права доступа
Команда ls -l выводит много информации о права доступа к каждому файлу:

$ ls -l test.txt
  -rw-rw-r--  1  user  group  1097374 January 26 2:48 test.txt
Вывод в примере	Описание / возможные выводы
—	Тип файла:
- файл
d каталог
rw-	Права доступа владельца файла
rw-	Права доступа членов группы-владельца файла
r–	Права доступа прочих пользователей
user	Имя владельца файла
group	Имя группы-владельца файла
chmod
Команда chmod изменяет права доступа файла. Вот типичные сочетания флагов для изменения прав конкретных пользователей:

Буква	Пользователь
u	Владелец
g	Член группы
o	Прочие пользователи
a	Все пользователи
Вы можете вызвать chmod с описанием действий над конкретным файлом. Символ - обозначает удаление прав, символ + — добавление. Следующий пример сделает файл доступным для чтения и записи владельцу и группе:

$ chmod ug+rw test.txt
$ ls -l test.txt
  -rw-rw----  1  user  group  1097374 January 26 2:48 test.txt
Кроме того, chmod можно использовать с восьмеричными числами, где 1 — это наличие прав, а 0 — отсутствие:

rwx = 111 = 7
rw- = 110 = 6
r-x = 101 = 5
r-- = 100 = 4
Следующая команда сработает так же, как и предыдущая:

$ chmod 660 test.txt
Также можно ознакомиться с руководством по правам доступа.

Сочетания клавиш
Сочетание	Описание
CTRL-A	Перемещение курсора в начало строки
CTRL-E	Перемещение курсора в конец строки
CTRL-R	Поиск по истории
CTRL-W	Вырезать последнее слово
CTRL-U	Вырезать всё до курсора
CTRL-K	Вырезать всё после курсора
CTRL-Y	Вернуть последнюю вырезанную строку
CTRL-_	Отмена
CTRL-L	Очистка экрана терминала
